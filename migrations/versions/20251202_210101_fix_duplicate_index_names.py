"""fix_duplicate_index_names

Revision ID: 20251202_210101
Revises: 20251201_213706
Create Date: 2025-12-02 21:01:01.000000

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '20251202_210101'
down_revision = '20251201_213706'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    
    # 对于MySQL，我们需要先删除重复的索引，然后创建新的索引
    # 注意：这里需要根据数据库类型进行不同的处理
    
    # 检查数据库类型
    conn = op.get_bind()
    db_type = conn.dialect.name
    
    if db_type == 'mysql':
        # MySQL处理方式
        # 删除CheckinRule表中的重复索引
        op.drop_index('idx_solo_user', table_name='checkin_rules')
        # 创建新的索引
        op.create_index('idx_rule_solo_user', 'checkin_rules', ['solo_user_id'])
        
        # 删除CheckinRecord表中的重复索引
        op.drop_index('idx_solo_user', table_name='checkin_records')
        # 创建新的索引
        op.create_index('idx_record_solo_user', 'checkin_records', ['solo_user_id'])
        
        # 重命名其他索引以保持一致性
        op.drop_index('idx_rule', table_name='checkin_records')
        op.create_index('idx_record_rule', 'checkin_records', ['rule_id'])
    
    elif db_type == 'sqlite':
        # SQLite处理方式
        # 由于SQLite的限制，我们需要重建表
        # 这里简化处理，直接创建新索引
        try:
            op.create_index('idx_rule_solo_user', 'checkin_rules', ['solo_user_id'], unique=False)
        except Exception:
            pass  # 索引可能已存在
        
        try:
            op.create_index('idx_record_solo_user', 'checkin_records', ['solo_user_id'], unique=False)
        except Exception:
            pass  # 索引可能已存在
        
        try:
            op.create_index('idx_record_rule', 'checkin_records', ['rule_id'], unique=False)
        except Exception:
            pass  # 索引可能已存在
    
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    
    # 检查数据库类型
    conn = op.get_bind()
    db_type = conn.dialect.name
    
    if db_type == 'mysql':
        # MySQL回滚方式
        # 删除新索引
        op.drop_index('idx_rule_solo_user', table_name='checkin_rules')
        op.drop_index('idx_record_solo_user', table_name='checkin_records')
        op.drop_index('idx_record_rule', table_name='checkin_records')
        
        # 重新创建原来的索引（会产生冲突，但在回滚时是预期的）
        op.create_index('idx_solo_user', 'checkin_rules', ['solo_user_id'])
        op.create_index('idx_solo_user', 'checkin_records', ['solo_user_id'])
        op.create_index('idx_rule', 'checkin_records', ['rule_id'])
    
    elif db_type == 'sqlite':
        # SQLite回滚方式
        try:
            op.drop_index('idx_rule_solo_user', table_name='checkin_rules')
        except Exception:
            pass
        
        try:
            op.drop_index('idx_record_solo_user', table_name='checkin_records')
        except Exception:
            pass
        
        try:
            op.drop_index('idx_record_rule', table_name='checkin_records')
        except Exception:
            pass
    
    # ### end Alembic commands ###