# 微信与手机注册流程优化计划

## 背景与目标

当前系统中微信注册和手机注册存在不一致的问题，需要按照新的策略进行统一优化，确保用户体验的一致性和数据管理的统一性。

### 新策略核心原则

1. 手机注册时，绝对不能采用类似微信的"静默登录"策略。必须手机号和密码同时正确才行。
2. 制定统一的账号合并规则：
   - 主账号优先级：微信账号 > 手机号账号
   - 合并方向：总是保留注册时间较早的账号作为主账号
   - 数据迁移：将新账号的数据合并到主账号
3. 使用任何一种方式登录成功后，都需要把微信open_id和手机号作为用户基本信息返回到前端
4. 无论是哪种登录方式，前端都检查返回的login_type字段
5. 暂时不增加账号管理功能
6. 暂时也不增加账号切换功能

## 必须修改的4个关键点

### 1. 高优先级修改（必须实施）

#### 1.1 严格分离注册和登录逻辑

**问题描述：**
- 当前`register_phone`函数在检测到已存在用户时，会验证密码并返回token
- 这违反了策略1，混淆了注册和登录的语义

**修改方案：**
```python
def register_phone():
    # ... 参数验证 ...
    
    # 检查手机号是否已存在
    existing = User.query.filter_by(phone_hash=phone_hash).first()
    
    if existing:
        # 严格按策略1：不验证密码，直接提示账号已存在
        return make_err_response({'code': 'PHONE_EXISTS'}, '该手机号已注册，请直接登录')
    
    # 创建新用户
    # ...
```

**影响范围：**
- 文件：`src/wxcloudrun/views.py`
- 函数：`register_phone`
- 前端需要处理新的错误码`PHONE_EXISTS`

#### 1.2 统一账号合并实现

**问题描述：**
- 当前绑定微信和绑定手机的合并逻辑不一致
- 违反了策略2.2（总是保留注册时间较早的账号）

**修改方案：**
```python
def _merge_accounts_by_time(account1, account2):
    """按注册时间合并账号，保留较早的账号"""
    if account1.created_at < account2.created_at:
        primary, secondary = account1, account2
    else:
        primary, secondary = account2, account1
    
    # 迁移数据
    _migrate_user_data(secondary.user_id, primary.user_id)
    
    # 更新主账号信息
    if not primary.wechat_openid and secondary.wechat_openid:
        primary.wechat_openid = secondary.wechat_openid
    if not primary.phone_hash and secondary.phone_hash:
        primary.phone_hash = secondary.phone_hash
        primary.phone_number = secondary.phone_number
    
    # 禁用次要账号
    secondary.status = 2
    db.session.commit()
    
    return primary

# 修改绑定手机号逻辑
@app.route('/api/user/bind_phone', methods=['POST'])
@login_required
def bind_phone(decoded):
    # ...
    if target and target.user_id != current_user.user_id:
        primary = _merge_accounts_by_time(current_user, target)
        _audit(current_user.user_id, 'bind_phone', {'phone': phone})
        return make_succ_response({'message': '绑定手机号成功，账号已合并'})
    # ...

# 修改绑定微信逻辑
@app.route('/api/user/bind_wechat', methods=['POST'])
@login_required
def bind_wechat(decoded):
    # ...
    if existing_wechat and existing_wechat.user_id != current_user.user_id:
        primary = _merge_accounts_by_time(current_user, existing_wechat)
        _audit(existing_wechat.user_id, 'bind_wechat_merge', {'from_user_id': current_user.user_id})
        return make_succ_response({'message': '绑定微信成功，账号已合并'})
    # ...
```

**影响范围：**
- 文件：`src/wxcloudrun/views.py`
- 函数：`bind_phone`, `bind_wechat`
- 新增函数：`_merge_accounts_by_time`

### 2. 中优先级修改（建议实施）

#### 2.1 统一登录响应格式

**问题描述：**
- 微信登录和手机登录返回的字段不一致
- 不满足策略3的要求

**修改方案：**
```python
def _format_user_login_response(user, token, refresh_token, is_new_user=False):
    """统一格式化登录响应"""
    return {
        'token': token,
        'refresh_token': refresh_token,
        'user_id': user.user_id,
        'wechat_openid': user.wechat_openid,
        'phone_number': user.phone_number,
        'nickname': user.nickname,
        'avatar_url': user.avatar_url,
        'role': user.role_name,
        'login_type': 'new_user' if is_new_user else 'existing_user'
    }

# 修改微信登录响应
@app.route('/api/login', methods=['POST'])
def login():
    # ...
    response_data = _format_user_login_response(
        user, token, refresh_token, is_new
    )
    return make_succ_response(response_data)

# 修改手机登录响应
@app.route('/api/auth/login_phone', methods=['POST'])
def login_phone():
    # ...
    response_data = _format_user_login_response(
        user, token, refresh_token, is_new=False
    )
    return make_succ_response(response_data)
```

**影响范围：**
- 文件：`src/wxcloudrun/views.py`
- 函数：`login`, `login_phone`, `register_phone`
- 新增函数：`_format_user_login_response`
- 前端需要适配新的响应格式

#### 2.2 完善数据迁移逻辑

**问题描述：**
- 当前`_migrate_user_data`函数可能存在数据丢失风险
- 需要处理数据冲突的情况

**修改方案：**
```python
def _migrate_user_data(src_user_id, dst_user_id):
    """改进的数据迁移函数，增加事务处理和冲突解决"""
    try:
        with db.session.begin_nested():
            # 迁移打卡规则（排除已删除的）
            rules = CheckinRule.query.filter(
                CheckinRule.solo_user_id == src_user_id,
                CheckinRule.status != 2
            ).all()
            for r in rules:
                # 检查是否已存在同名规则
                existing_rule = CheckinRule.query.filter(
                    CheckinRule.solo_user_id == dst_user_id,
                    CheckinRule.rule_name == r.rule_name,
                    CheckinRule.status != 2
                ).first()
                if not existing_rule:
                    r.solo_user_id = dst_user_id
            
            # 迁移打卡记录
            records = CheckinRecord.query.filter(
                CheckinRecord.solo_user_id == src_user_id
            ).all()
            for rec in records:
                rec.solo_user_id = dst_user_id
            
            # 迁移监护关系（作为被监护人）
            rels = SupervisionRuleRelation.query.filter(
                SupervisionRuleRelation.solo_user_id == src_user_id
            ).all()
            for rel in rels:
                # 检查是否已存在相同关系
                existing_rel = SupervisionRuleRelation.query.filter(
                    SupervisionRuleRelation.solo_user_id == dst_user_id,
                    SupervisionRuleRelation.supervisor_user_id == rel.supervisor_user_id,
                    SupervisionRuleRelation.status != 2
                ).first()
                if not existing_rel:
                    rel.solo_user_id = dst_user_id
            
            # 迁移监护关系（作为监护人）
            rels2 = SupervisionRuleRelation.query.filter(
                SupervisionRuleRelation.supervisor_user_id == src_user_id
            ).all()
            for rel in rels2:
                # 检查是否已存在相同关系
                existing_rel = SupervisionRuleRelation.query.filter(
                    SupervisionRuleRelation.solo_user_id == rel.solo_user_id,
                    SupervisionRuleRelation.supervisor_user_id == dst_user_id,
                    SupervisionRuleRelation.status != 2
                ).first()
                if not existing_rel:
                    rel.supervisor_user_id = dst_user_id
            
            db.session.commit()
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'数据迁移失败: {str(e)}', exc_info=True)
        raise e
```

**影响范围：**
- 文件：`src/wxcloudrun/views.py`
- 函数：`_migrate_user_data`

### 3. 低优先级优化（可选实施）

#### 3.1 添加详细的日志记录

**修改方案：**
```python
def _merge_accounts_by_time(account1, account2):
    """按注册时间合并账号，保留较早的账号"""
    app.logger.info(f'开始合并账号: {account1.user_id} 和 {account2.user_id}')
    
    if account1.created_at < account2.created_at:
        primary, secondary = account1, account2
        app.logger.info(f'保留主账号: {primary.user_id} (创建时间: {primary.created_at})')
    else:
        primary, secondary = account2, account1
        app.logger.info(f'保留主账号: {primary.user_id} (创建时间: {primary.created_at})')
    
    # ... 迁移逻辑 ...
    
    app.logger.info(f'账号合并完成: 主账号 {primary.user_id}, 次账号 {secondary.user_id} 已禁用')
    return primary
```

#### 3.2 增加事务处理

**修改方案：**
```python
@app.route('/api/user/bind_phone', methods=['POST'])
@login_required
def bind_phone(decoded):
    try:
        with db.session.begin_nested():
            # ... 绑定逻辑 ...
            pass
    except Exception as e:
        db.session.rollback()
        app.logger.error(f'绑定手机号失败: {str(e)}', exc_info=True)
        return make_err_response({}, f'绑定手机号失败: {str(e)}')
```

## 实施计划

### 第一阶段：高优先级修改
1. 修改`register_phone`函数，移除静默登录逻辑
2. 创建`_merge_accounts_by_time`函数
3. 修改`bind_phone`和`bind_wechat`使用统一合并逻辑
4. 测试账号合并功能

### 第二阶段：中优先级修改
1. 创建`_format_user_login_response`函数
2. 修改所有登录相关接口使用统一响应格式
3. 改进`_migrate_user_data`函数，增加冲突处理
4. 前端适配新的响应格式

### 第三阶段：低优先级优化
1. 添加详细的日志记录
2. 增加事务处理
3. 性能优化和代码重构

## 测试计划

### 功能测试
1. 手机注册重复手机号测试
2. 账号合并功能测试（微信+手机）
3. 登录响应格式测试
4. 数据迁移完整性测试

### 边界情况测试
1. 同一用户多次绑定测试
2. 数据冲突处理测试
3. 网络异常时的事务回滚测试

### 性能测试
1. 大量数据迁移的性能测试
2. 并发绑定的测试

## 风险评估

### 高风险
- 数据迁移可能导致数据丢失
- 账号合并逻辑错误可能导致用户无法登录

### 缓解措施
- 在修改前备份重要数据
- 分阶段实施，每个阶段充分测试
- 准备回滚方案

## 完成标准

1. 所有高优先级修改完成并通过测试
2. 中优先级修改完成
3. 文档更新完成
4. 生产环境部署成功

---

*文档创建时间：2025-12-07*
*最后更新时间：2025-12-07*